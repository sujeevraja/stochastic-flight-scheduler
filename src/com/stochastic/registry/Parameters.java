package com.stochastic.registry;

public class Parameters {
    private static String instancePath;
    private static int rescheduleTimeBudget;
    private static int numScenariosToGenerate;
    private static double scale;
    private static double shape;
    private static int[] durations;
    private static boolean bendersMultiCut;
    private static double bendersTolerance;
    private static int numBendersIterations;

    /**
     * ReducedCostStrategy specifies the strategy to use for selecting columns generated by the pricing problem.
     *
     * ALL_PATHS: finish the labeling procedure and use all negative reduced cost paths.
     * BEST_PATHS: finish the labeling procedure and use a specific number of the most negative reduced cost paths.
     * FIRST_PATHS: exit the labeling procedure as soon as a specific number of paths have been found.
     *
     * The number of paths for the BEST_PATHS and FIRST_PATHS strategy is specified using "numReducedCostPaths."
     */
    public enum ReducedCostStrategy {
        ALL_PATHS,
        BEST_PATHS,
        FIRST_PATHS,
    }
    private static ReducedCostStrategy reducedCostStrategy;
    private static int numReducedCostPaths; // number of reduced cost paths to collect in second stage.

    private static boolean fullEnumeration; // set to false to use labeling procedure
    private static boolean debugVerbose; // generates additional logging, writes lP files and solutions.

    private static boolean runSecondStageInParallel = false;
    private static int numThreadsForSecondStage = 1;

    // Parameters to check 2-stage solution quality
    private static boolean checkSolutionQuality;
    private static int numTestScenarios;

    // Parameters for expected excess formulation
    private static boolean expectedExcess;
    private static double rho;
    private static double excessTarget;

    public static void setInstancePath(String instancePath) {
        Parameters.instancePath = instancePath;
    }

    public static String getInstancePath() {
        return instancePath;
    }

    public static void setRescheduleTimeBudget(int rescheduleTimeBudget) {
        Parameters.rescheduleTimeBudget = rescheduleTimeBudget;
    }

    public static int getRescheduleTimeBudget() {
        return rescheduleTimeBudget;
    }

    public static void setNumScenariosToGenerate(int numScenariosToGenerate) {
        Parameters.numScenariosToGenerate = numScenariosToGenerate;
    }

    public static int getNumScenariosToGenerate() {
        return numScenariosToGenerate;
    }

    public static void setScale(double scale) {
        Parameters.scale = scale;
    }

    public static double getScale() {
        return scale;
    }

    public static void setShape(double shape) {
        Parameters.shape = shape;
    }

    public static double getShape() {
        return shape;
    }

    public static void setDurations(int[] durations) {
        Parameters.durations = durations;
    }

    public static int[] getDurations() {
        return durations;
    }

    public static int getNumDurations() {
        return durations.length;
    }

    public static void setBendersMultiCut(boolean bendersMultiCut) {
        Parameters.bendersMultiCut = bendersMultiCut;
    }

    public static boolean isBendersMultiCut() {
        return bendersMultiCut;
    }

    public static void setBendersTolerance(double bendersTolerance) {
        Parameters.bendersTolerance = bendersTolerance;
    }

    public static double getBendersTolerance() {
        return bendersTolerance;
    }

    public static void setNumBendersIterations(int numBendersIterations) {
        Parameters.numBendersIterations = numBendersIterations;
    }

    public static int getNumBendersIterations() {
        return numBendersIterations;
    }

    public static void setReducedCostStrategy(ReducedCostStrategy reducedCostStrategy) {
        Parameters.reducedCostStrategy = reducedCostStrategy;
    }

    public static ReducedCostStrategy getReducedCostStrategy() {
        return reducedCostStrategy;
    }

    public static void setNumReducedCostPaths(int numReducedCostPaths) {
        Parameters.numReducedCostPaths = numReducedCostPaths;
    }

    public static int getNumReducedCostPaths() {
        return numReducedCostPaths;
    }

    public static void setFullEnumeration(boolean fullEnumeration) {
        Parameters.fullEnumeration = fullEnumeration;
    }

    public static boolean isFullEnumeration() {
        return fullEnumeration;
    }

    public static void setRunSecondStageInParallel(boolean runSecondStageInParallel) {
        Parameters.runSecondStageInParallel = runSecondStageInParallel;
    }

    public static boolean isRunSecondStageInParallel() {
        return runSecondStageInParallel;
    }

    public static void setNumThreadsForSecondStage(int numThreadsForSecondStage) {
        Parameters.numThreadsForSecondStage = numThreadsForSecondStage;
    }

    public static int getNumThreadsForSecondStage() {
        return numThreadsForSecondStage;
    }

    public static void setCheckSolutionQuality(boolean checkSolutionQuality) {
        Parameters.checkSolutionQuality = checkSolutionQuality;
    }

    public static boolean isCheckSolutionQuality() {
        return checkSolutionQuality;
    }

    public static void setNumTestScenarios(int numTestScenarios) {
        Parameters.numTestScenarios = numTestScenarios;
    }

    public static int getNumTestScenarios() {
        return numTestScenarios;
    }

    public static void setExpectedExcess(boolean expectedExcess) {
        Parameters.expectedExcess = expectedExcess;
    }

    public static boolean isExpectedExcess() {
        return expectedExcess;
    }

    public static void setRho(double rho) {
        Parameters.rho = rho;
    }

    public static double getRho() {
        return rho;
    }

    public static void setExcessTarget(double excessTarget) {
        Parameters.excessTarget = excessTarget;
    }

    public static double getExcessTarget() {
        return excessTarget;
    }

    public static void setDebugVerbose(boolean debugVerbose) {
        Parameters.debugVerbose = debugVerbose;
    }

    public static boolean isDebugVerbose() {
        return debugVerbose;
    }
}
